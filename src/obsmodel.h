#pragma once

#include <boost/functional/hash.hpp> // so the observation model can use boost::hash if required

#include "config.h"
#include "model.h"
#include "global.h"
#include "duration.h"

// Make estimator classes available to observation model
#include "estimate/estimators.h"

#ifndef OBSERVATION_MODEL_HEADER
#error "OBSERVATION_MODEL_HEADER not defined"
#endif

/*
 * The definitions contained here must all be defined in the user-defined observation model.
 * We require that the user defined / generated model consists of two files.
 * Each file has to be defined as one preprocessor macro (enclosed in double quotes).
 * OBSERVATION_MODEL_HEADER: header of the observation model
 * OBSERVATION_MODEL_IMPL: implementation of the observation model
 *
 * The OBSERVATION_MODEL_HEADER must only include non-standard definitions
 * (i.e. those not included here)
 */

namespace model {

#include OBSERVATION_MODEL_HEADER

#ifndef SUPPORTS_PYA
#define SUPPORTS_PYA 0
#endif

#ifndef SUPPORTS_OBS_EQUIV
#define SUPPORTS_OBS_EQUIV 0
#endif

#ifndef SUPPORTS_OBS_HASH
#define SUPPORTS_OBS_HASH 0
#endif

bool fetchObservation();

// pre_observe_*: prepare observation model for observations
// post_observe_*: do the observations
// these function assume that action and state observations are independent
// (if it turns out to not hold for some models, we may add joint *_observe_state_action functions)
void pre_observe_action(size_t agid);
void pre_observe_state(StatePtr s);
void pre_observe_state(const StateRec &s);
Probability post_observe_action(size_t agid);
Probability post_observe_state(StatePtr s);
Probability post_observe_state(const StateRec &s);

void specialOpCallback(int agid, int opid);

#if SUPPORTS_PYA
Probability getActionProbability(const StateRec &s);
#endif

// TODO add multi-agent case
#ifdef USE_ACTION_OBSERVATION
void actionCallback(int opid);
#endif


// Call all action :observation clauses
void do_action_callback(const Model::opid_t &opid, const StateRec &s);
// Call all state :observation clauses
void do_state_callback(const StateRec &s);

// Call all state and action :observation clauses defined in the model
void doCallbacksAndObservations(const Model::opid_t &opid, const StateRec &s);

// Tests for observation-equivalent particles
// this may be used to merge equivalent particles into one particle (which represents a set of possible particles)
// (Only required to actually define if SUPPORTS_OBS_EQUIV has been defined)

// TODO: handle goal distances and action saliencies / action durations
// eventually, these functions should be generated by rcg based on :observation, :duration, :saliency, etc.

// return whether both state/action combinations cannot be distinguished in this observation model
// It must be symmetric and transitive
bool observationEquivalent(const StateRec &s1, const Model::opid_t &opid1, const StateRec &s2, const Model::opid_t &opid2);

// returns a hash_value for one <S, A> state
// The following must hold for all S1, A1, S2, A2:
// if <S1, A1> == <S2, A2> (wrt. observationEquivalent), than hash_value(<S1, A1>) == hash_value(<S2, A2>)
//
// Only required to actually define if SUPPORTS_OBS_HASH has been defined
// However, defining this increases the performance for the filtering with observation-equivalent particles
size_t observation_hash_value(const StateRec &s, const Model::opid_t &opid);

} // namespace model
